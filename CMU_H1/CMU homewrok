
Ans 2):

SELECT
    startyear || '|' || primarytitle || ' (' || originaltitle || ')' AS movie_details
FROM
    title_basics
WHERE
    titletype = 'movie' -- Consider only movies
    AND genres @> ARRAY['Action'] -- Check if Action is one of the genres
    AND primarytitle <> originaltitle -- Filter out movies with the same primary and original title
ORDER BY
    startyear DESC, primarytitle -- Sort by startyear in descending order, then by primarytitle in ascending order
LIMIT 10;


Ans 3):

SELECT
    primarytitle || '|' || (COALESCE(endyear, 2023) - startyear) AS series_details
FROM
    title_basics
WHERE
    titletype = 'tvSeries' -- Consider only TV series
    AND startyear IS NOT NULL -- Exclude TV series without a premiered year
ORDER BY
    (COALESCE(endyear, 2023) - startyear) DESC, primarytitle -- Sort by years running in descending order, then by primarytitle in ascending order
LIMIT 20;


Ans 4):

SELECT
    CONCAT(
        CONCAT((birth_decade - 1) * 10, 's'),
        '|',
        COUNT(*) AS num_directors
    )
FROM (
    SELECT
        FLOOR(birthyear / 10) AS birth_decade
    FROM
        name_basics
    WHERE
        name_basics.birt_hyear >= 1900 -- Consider directors born since 1900
        AND name_basics.birth_year IS NOT NULL -- Exclude directors without a birth year
) AS subquery
GROUP BY
    birth_decade
ORDER BY
    birth_decade;


SELECT
    tb.titletype,
    ROUND(AVG(tr.average_rating)::numeric, 2) AS avg_rating,
    MIN(tr.average_rating) AS min_rating,
    MAX(tr.average_rating) AS max_rating
FROM
    title_basics tb
    JOIN title_ratings tr ON tb.tconst = tr.tconst
    JOIN title_akas ta ON tb.tconst = ta.title_id
WHERE
    ta.title = tb.originaltitle -- Match German titles
    AND ta.types IN ('{imdbDisplay}', '{original}') -- Consider akas types imdbDisplay or original
GROUP BY
    tb.titletype
ORDER BY
    avg_rating DESC;


Ans 6): 

SELECT
    nb.primary_name,
    ROUND(AVG(tr.average_rating)::numeric, 2) AS avg_rating
FROM
    name_basics nb
    JOIN title_principals tp ON nb.nconst = tp.nconst
    JOIN title_ratings tr ON tp.tconst = tr.tconst
WHERE
    nb.primary_name IN (
        SELECT
            nb.primary_name
        FROM
            name_basics nb
            JOIN title_principals tp ON nb.nconst = tp.nconst
            JOIN title_basics tb ON tp.tconst = tb.tconst
        WHERE
            tb.originaltitle = 'Batman'
            AND tp.category = 'actor'
    )
GROUP BY
    nb.primary_name
ORDER BY
    avg_rating DESC
LIMIT 10;



Ans 7):

SELECT
    COUNT(DISTINCT nb.nconst) AS total_actors
FROM
    name_basics nb
    JOIN title_principals tp ON nb.nconst = tp.nconst
    JOIN title_basics tb ON tp.tconst = tb.tconst
WHERE
    tb.originaltitle = 'The Prestige'
    AND EXTRACT(YEAR FROM to_date(tb.premiered::text, 'YYYY')) = nb.birthyear
    AND tp.category IN ('actor', 'actress');


Ans 8):

SELECT DISTINCT nb.primary_name
FROM
    name_basics nb
    JOIN title_principals tp ON nb.nconst = tp.nconst
    JOIN name_basics na ON tp.nconst = na.nconst
WHERE
    na.primary_name LIKE 'Rose%'
    AND tp.category IN ('actor', 'actress')
    AND EXISTS (
        SELECT 1
        FROM unnest(nb.primary_profession) prof
        WHERE prof LIKE '%director%'
    )
ORDER BY nb.primary_name;



--the execution time of the below  queries is too long so first create indicees before running the queries:
-- Index on name_basics table
CREATE INDEX idx_name_basics_nconst ON name_basics (nconst);

-- Index on title_principals table
CREATE INDEX idx_title_principals_nconst ON title_principals (nconst);
CREATE INDEX idx_title_principals_tconst ON title_principals (tconst);

-- Index on title_basics table
CREATE INDEX idx_title_basics_tconst ON title_basics (tconst);








Ans 9):

WITH ranked_cast AS (
    SELECT
        np.nconst,
        np.primary_name,
        np.death_year,
        tp.category,
        tb.tconst,
        tb.primarytitle,
        tb.runtimeminutes,
        ROW_NUMBER() OVER (
            PARTITION BY tp.category, np.nconst
            ORDER BY np.death_year NULLS LAST, tb.runtimeminutes DESC, tb.tconst
        ) AS category_rank
    FROM
        name_basics np
        JOIN title_principals tp ON np.nconst = tp.nconst
        JOIN title_basics tb ON tp.tconst = tb.tconst
    WHERE
        tp.category IN ('actor', 'actress')
        AND tb.runtimeminutes IS NOT NULL
)
SELECT
    rc.category,
    rc.primary_name AS name,
    rc.death_year,
    rc.primarytitle AS longest_work_title,
    rc.runtimeminutes AS work_runtime,
    rc.category_rank
FROM
    ranked_cast rc
WHERE
    rc.category_rank <= 5
ORDER BY
    rc.category,
    rc.death_year NULLS LAST,
    rc.primary_name,
    rc.runtimeminutes DESC,
    rc.tconst;




    

Ans 10):

WITH RECURSIVE character_list AS (
    SELECT
        tp.tconst,
        tp.characters,
        1 AS level
    FROM
        name_basics nb
        JOIN title_principals tp ON nb.nconst = tp.nconst
    WHERE
        nb.primary_name = 'Leonardo DiCaprio'
        AND nb.birth_year = 1974
    UNION ALL
    SELECT
        cl.tconst,
        substring(cl.characters, p + 2) AS characters,
        cl.level + 1
    FROM
        character_list cl
        CROSS JOIN LATERAL (
            SELECT
                position(',' IN cl.characters) AS p
        ) AS subquery
    WHERE
        subquery.p > 0
)
SELECT
    string_agg(DISTINCT characters, ',' ORDER BY characters) AS unique_characters
FROM
    character_list
WHERE
    characters NOT LIKE '%Self%'
ORDER BY
    unique_characters;





